# Size Classes

There are only two type: Compact and Regular.

- Compact: Small
- Regular: Big (I don't know why they call it regular)

For example, on an iPad landscape mode, both horizontal and vertical are regular. On an iPhone, when it's in portrait mode, the horizontal is compact and the vertical is regular.

The combinations are:
- Compact width, regular height (portrait)
- Compact height, regular width (landscape)
- Regular width, regular height (iPad landscape)

The modes are:
- 2/3 Split View
- 1/2 Split View
- 1/3 Split View

```swift
import SwiftUI

struct ContentView: View {

	@Environment(\.verticalSizeClass) var vertical
	@Environment(\.horizontalSizeClass) var horizontal

	var body: some View {
		Text(vertical == .compact ? "I'm Landscape", "I'm Portrait")
			.font(.largeTitle)
			.bold()
			.foregroundCOlor(vertical == .compact ? .red : .blue)
			.padding()
	}
}

struct ContentView_Previews: PreviewProvider {
	static var previews: some View {
		ContentView()
	}
}

```

# Alamofire

## Cocoapods

```
// Podfile
pod 'Alamofire'
```

## Carthage

```
// Cartfile
github "Alamofire/Alamofire"
```

## Swift Package Manager

```
dependencies: [
	.package(url: "https://github.com/Alamofire/Alamofire.git", .upToNextMajor(from: "5.6.1"))
]
```

## Usages

```swift
AF.request("https://httpbin.org/get").response {response in
	debugPrint(response)
}

AF.request("https://httpbin.org/get")
AF.request("https://httpbin.org/post", method: .post)
AF.request("https://httpbin.org/put", method: .put)
AF.request("https://httpbin.org/delete", method: .delete)

AF.download("https://httpbin.org/image/png").responseURL { response in 
	// Read file from provided file URL
}

let destination: DownloadRequest.Destination = { _, _ in
	let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
	let fileURL = documentsURL.appendingPathComponent("image.png")
	return (fileURL, [.removePreviousFile, .createIntermediateDirectories])
}

AF.download("https://httpbin.org/image/png", to: destination).response { response in
	debugPrint(response)

	if response.error == nil, let imagePath = response.fileURL?.path {
		let image = UIImage(contentsOfFile: imagePath)
	}
}

AF.upload(multipartFormData: { multipartFormData in
	multipartFormData.append(Data("one".utf8), withName: "one")
	multipartFormData.append(Data("two".utf8), withName: "two")
}, to: "https://httpbin.org/post")
	.responseDecodable(of: DecodableType.self) {response in
		debugPrint(response)
	}
```

# iOS Concurrency Problems

## Problems

- Starvation (Priority Inversion)

Low Priority locks resource high priority waits

- Race condition

- Deadlock

Task A hold resource x. Task B hold resource y.
Task A ask resource y. Task B ask resource x

## Solutions

- One Quality of Service for accessing shared resource
- Serial queue to access shared resource
- Barier task (Dispatching barrier)
- Dispatch group
